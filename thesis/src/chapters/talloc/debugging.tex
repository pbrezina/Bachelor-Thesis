\section{Debugging options}

Although talloc makes memory management significantly easier than the standard
library does, developers are still only humans. Therefore it may be a good idea
to know the tools for the inspection of talloc memory usage.

\subsection{Usage reports}

\subsection{Leak check routines}

We frequently need to provide a talloc context as a parameter to a function, so
this function can use it as a parent context for output values. But sometimes a
programmer makes a mistake and allocates something more than he is supposed to.

This issue can not be usually seen in talloc reports, but fortunately it can be
tested automatically with the knowledge of total size (size of a context and
its children) of the parent context.

\begin{lstlisting}[caption={Leak check example}]
/* creates new talloc context *_foo as a child of mem_ctx */
int struct_foo_init(TALLOC_CTX *mem_ctx, struct foo **_foo);

int ret;
size_t total_size;
struct foo *foo = NULL;
TALLOC_CTX *ctx = talloc_new(NULL);

total_size = talloc_total_size(ctx)
ret = struct_foo_init(test_ctx, &foo);
talloc_free(foo);
if (total_size != talloc_total_size(ctx)) {
  /* struct_foo_init() allocated on 'ctx'
     more than 'foo' */
}
\end{lstlisting}

However such checks are not suitable for an application itself as we have to
free |foo| before other usage of the parent context. Therefore the proper place
for this is in your test suit, possibly in unit tests. If you are using the
Check\footnote{\url{http://check.sourceforge.net}} library for unit testing in
C, I suggest you use the methods of Martin Nagy.

Martin Nagy, a former developer of SSSD, invented a set of functions which goal
is to detect memory leaks on a talloc context in unit tests created with the
Check library (but it can be easily modified for other test suits). It does it
in a more advance manner than the previous example introduced. It works on a
push/pop basis, where the unit test will fail if a context has after the pop
operation different size than it had during the push operation.


\begin{lstlisting}[caption={Martin Nagy's leak check routines},
morekeywords={leak_check_setup,check_leaks_push,
              check_leaks_pop,leak_check_teardown}]
/* creates new talloc context *_foo as a child of mem_ctx */
int struct_foo_init(TALLOC_CTX *mem_ctx, struct foo **_foo);

/* create new unit test with Check library */
START_TEST(test_struct_foo_init)
{
  int ret;
  struct foo *foo = NULL;
  TALLOC_CTX *test_ctx = talloc_new(NULL);
  fail_if(test_ctx == NULL); /* if the condition is met,
                                the unit test will fail */
  
  /* initialize the leak check routines */
  leak_check_setup();
  
  /* remember current test_ctx total size */
  check_leaks_push(test_ctx);
  
  ret = struct_foo_init(test_ctx, &foo);
  fail_if(ret != EOK)
  
  /* ... test foo values ... */
  
  talloc_free(foo);
  
  /* check for memory leak,
     this will fail the test if struct_foo_init()
     allocated more than 'foo' on test_ctx */
  check_leaks_pop(test_ctx);
  
  talloc_free(test_ctx);
  
  /* clean up after the leak check routines */
  leak_check_teardown();(*@\footnotemark@*)
}
\end{lstlisting}
\footnotetext{setup and teardown functions can be run automatically with
\lstinline{tcase_add_}\lstinline{checked_fixture()}}

% /* initialize unit tests */
% Suite *
% create_suite(void)
% {
%   Suite *s = suite_create("foo tests");
%   TCase *tc = tcase_create("foo tests");
% 
%   /* run leak_check_setup() before and 
%      leak_check_teardown() after each unit test */
%     tcase_add_checked_fixture(tc, leak_check_setup, leak_check_teardown);
%     
%   /* register unit tests */
%   tcase_add_test(tc, test_struct_foo_init);
% 
%   /* add all test cases to the test suite */
%   suite_add_tcase(s, tc);
% 
%   return s;
% }

\label{talloc:sec:debugging}