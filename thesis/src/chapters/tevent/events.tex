\section{Registering events}

Tevent supports several event types: timers,  signals, file descriptor events
(readiness for reading or writing) and immediate events. Each of these
are supported by all built-in event backends.

Although we have to use different functions to set up a new event handler for
each kind of event, their usage and prototypes are very similar. In order to
register an event handler, we have to provide five pieces of information:

\begin{itemize}
  \item the event context where the event handler will be registered,
  \item a talloc memory context which will be used as a parent for this handler
  meta data,
  \item private data that will be passed to the handler,
  \item the event handler itself,
  \item plus some event specific parameters (time, signal number, file
  descriptor, \ldots).
\end{itemize}

The functions return a pointer to an event specific structure or |NULL| on
error. This structure is a talloc context. We must not set a destructor on this
context because it already contains one -- when we call |talloc_free()| on this
pointer the event handler will be automatically unregistered from the event
context.

\subsection{Timers}

Timers are events that are triggered after a specified time span has left. The
important thing to know is that this kind of event is not triggered exactly
when the selected time is reached but as soon as possible after it is reached.
Therefore it can not be used in situations where the accuracy is critical.

To create a timed event, we will use:

\begin{funcproto}
struct tevent_timer* tevent_add_timer(
             struct tevent_context *event_ctx,
             TALLOC_CTX *mem_ctx,
             struct timeval next_event,
             tevent_timer_handler_t handler,
             void *private_data)
\end{funcproto}
\funclistend
The |next_event| parameter contains the absolute time when this event should be
fired. Tevent contains several utility functions\cite{TeventDocTimeval}
that helps us with the creation of |timeval| structure. In most cases we will
want to use an offset that is relative to the current time. This can be achieved
with:

\begin{funcproto}
struct timeval tevent_timeval_current_ofs(uint32_t secs,
                                          uint32_t usecs)
\end{funcproto}
\funclistend
The event handler for timers has the following prototype:

\begin{funcproto}
void handler(struct tevent_context *event_ctx,
             struct tevent_timer *timer_event,
             struct timeval current_time,
             void *private_data)
\end{funcproto}
\funclistend
The |current_time| parameter is a little tricky. As its name suggests it
contains the absolute time when the handler has been called. But only if we have
provided a non-zero time in |tevent_add_timer()|. It will contain zero
otherwise. However we should use an immediate event for such cases.

Every timer in tevent is only a one time event (the |tevent_timer| structure is
freed once the handler returns). If we want it to be executed periodically we
have to call |tevent_add_timer()| in the handler again.

In our example we will set a periodical timer that will be fired every sixty
seconds.

\begin{lstlisting}[morekeywords={tevent_add_timer},name=PeriodicalUpdateDB]
struct tevent_timer* set_periodical_update_db(
                  struct tevent_context *ev,
                  TALLOC_CTX *mem_ctx,
                  void *pvt)
{
  struct timeval tv;
  tv = tevent_timeval_current_ofs(60, 0);
  return tevent_add_timer(ev, mem_ctx, tv,
                          periodical_update_db, pvt);
}
\end{lstlisting}
\begin{lstlisting}[caption={Periodical update of a database},firstnumber=auto,
morekeywords={set_periodical_update_db},name=PeriodicalUpdateDB]
void periodical_update_db(struct tevent_context *event_ctx,
                          struct tevent_timer *timer,
                          struct timeval current_time,
                          void *pvt)
{
  struct tevent_timer *timer = NULL;
  struct update_ctx *ctx = NULL;
  ctx = talloc_get_type_abort(pvt, struct update_ctx);

  update_db(ctx);
  
  timer = set_periodical_update_db(ev, ctx->mem_ctx, ctx);
  if (timer == NULL) {
    /* error */
  }
}
\end{lstlisting}

\subsection{Signals}

Signals are basically an asynchronous event with very high priority. They can be
described as an event that is sent to the application (usually) from the outer
world. Once the program receives this signal it will immediately pause the
current procedure and executes a handler of the received signal. After the
handler is finished the application will continue at the point where it was
interrupted.

Tevent supports standard POSIX signals, but it does it with a little bit
different and more advanced manner than we are used from the classic approach
with |signal()| or |sigaction()|.

The first difference and a big advantage is that it supports having multiple
handlers on a single signal. The handlers are then executed in the last
in first out order.

The second difference is that tevent breaks the standard thinking of the
signals as the events that can interrupt our application at any point. Once we
register a signal handler, the signal processing becomes a part of the
application processing -- the handler is executed only in the event loop when
the program is idle. However, we do not have to worry of loosing any signal.
When our program is not idle (it is not waiting in the event loop), tevent
counts any incoming signal that we have enrolled to and then gives this
information to the handler once it is called. This way we can be sure that we
will not interrupt our application in the middle of processing (for example
while inserting data into a database).

The most commonly used signals are:

\begin{itemize}
  \item |SIGINT|, |SIGTERM|, |SIGABRT| -- clean up before the application exits
  (unlink temporary files, close remote connections, notify children processes,
  \ldots).
  \item |SIGHUP| -- originally was used to notify the process when a remote
  modem hanged up, today it notifies that a virtual terminal has been closed.
  Service applications frequently use it to force a reload of a configuration,
  rotate logs or to do a graceful restart.
  \item |SIGUSR1|, |SIGUSR2| -- purpose of this signals is very arbitrary. It is
  often used to increase/decrease a debug level. SSSD uses it to force and reset
  offline mode.
\end{itemize}

\noindent
We can register a signal event handler with:

\begin{funcproto}
struct tevent_signal* tevent_add_signal(
             struct tevent_context *event_ctx,
             TALLOC_CTX *mem_ctx,
             int signum, int sa_flags,
             tevent_signal_handler_t handler,
             void *private_data)   
\end{funcproto}
\begin{funcdesc}
The |signum| parameter represents the signal we want to enroll to.
Parameter |sa_flags| is equivalent to the |sigaction| flags.
\end{funcdesc}
\funclistend
The event handler for signals has the following prototype:

\begin{funcproto}
void handler(struct tevent_context *event_ctx,
             struct tevent_signal *signal_event,
             int signum, int count, void *siginfo,
             void *private_data)
\end{funcproto}
\funclistend
Unless |SA_SIGINFO| flag is set during the registration, the handler will be
called only once and the parameter |count| will contain the number of how many
times was the signal |signum| received before the event handler was called.

But if |SA_SIGINFO| is set, the value of |count| will always be |1| and the
handler will be executed for each detected signal |signum|. Parameter |siginfo|
will contain a pointer to |siginfo_t| structure which provides additional
information about the signal and its source.

\subsection{File descriptor events}

\subsection{Immediate events}